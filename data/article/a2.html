<!doctype html>
<html><head>
<link rel='shortcut icon' href='../favicon.ico'>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no' />
<title>
gh-pagesでHPを公開する試み
</title>
<link rel='stylesheet' type='text/css' href='../css/common.css'>
</head><body>
<div class='breadcrumbs'>
<ul>
<li><a href='../'>gh-pagesでHPを公開する試み トップ</a></li>
<li><a href='../ctg2.html'>郵便・統計</a></li><li>“R”を使った空間統計</li></ul></div><div class='title'><h2 class='article'>“R”を使った空間統計</h2></div> <div class='keyarea'><a class='keyword'>　統計　</a><a>　</a><a class='keyword'>　R　</a><a>　</a><a class='keyword'>　地図　</a><a>　</a></div> <div class='article'><p>Rを用いて、クリギングによる補間処理を行う手法をまとめたものです。もっと良い方法がありそうな気もする。<br>参考にしたページはこちら<br><a href='http://nakhirot.hatenablog.com/entry/20130702/1372770938' target='_blank'> DSL_statblog “R Space interpolation 空間補間”</a></p><p>ディレクトリのパスにに８bit文字（日本語）は含まないようにしてください。不具合（ファイルの読み込み、出力ができない等）が出ることがあります。</p><div class='codearea'><pre><code># 必要なライブラリ <br>library(spdep)<br>library(maptools)<br>library(gstat)<br>library(sp)<br>library(raster)<br></code></pre></div><p>例として、NDVIデータ（Landsat8の画像から加工したもの）を用いる。<br>https://landsat.usgs.gov/landsat-level-1-standard-data-products<br>サンプルデータはこちら→準備中…</p><div class='codearea'><pre><code># シェープファイルの読み込み・表示<br>ndvih &lt- readShapePoly("NDVImesh16-0707.shp")<br># シェープファイル（ポリゴン）を読み込む。<br>summary(ndvih)<br>plot(ndvih, axes=T, col = gray(1-ndvih$mean/max(ndvih$mean))) <br># NDVIデータの表示（グレースケール）<br><br>ndvih_coord &lt- coordinates(ndvih) # 各ポリゴンの代表点を抽出<br></code></pre></div><div class='fig'><a href='./a2/1.png'><img src='./a2/1.png' class='fig'></a><p class='legend'>オリジナルのメッシュデータ（ポリゴン）。北大周辺、2016年7月7日撮影（Landsat8）。データ加工はQGIS（2.10.1）を用いて、ラスタデータの値をメッシュごとに平均計算させ、それをそれぞれのメッシュ（ポリゴン）に持たせた。</p></div><div class='codearea'><pre><code># クリギング用に上記メッシュデータを間引いて、どのくらい補間を再現できるか検討する<br><br># 欠損データの作成<br><br>na &lt-c(rep(NA, length=10), 1) # 11個中、1つ以外欠損値(NA)に置き換える。<br>ndvih_miss &lt- ndvih$mean*rep(na, length=length(ndvih$mean))<br>ndvih_x &lt- ndvih_coord[,1]*rep(na, length=length(ndvih_coord[,1]))<br>ndvih_y &lt- ndvih_coord[,2]*rep(na, length=length(ndvih_coord[,2]))<br>ndvih_miss &lt- ndvih_miss[!is.na(ndvih_miss)] # それぞれ、欠損値を除く<br>miss_x &lt- ndvih_x[!is.na(ndvih_x)]<br>miss_y &lt- ndvih_y[!is.na(ndvih_y)]<br><br>ndvi_miss &lt- cbind(miss_x, miss_y, ndvih_miss) # 行列の再構成<br>colnames(ndvi_miss) &lt- c("x","y","NDVI") # 列名を付ける<br>ndvi_miss &lt- as.data.frame(ndvi_miss) # データフレームに変換<br><br># データ形式をSpatialPointsDataFrameに変換する<br>coords &lt- cbind(ndvi_miss$x,ndvi_miss$y) # x,y座標をペアにする<br>ndvi_miss &lt- SpatialPointsDataFrame(coords,ndvi_miss)<br>coord &lt- coordinates(ndvi_miss)<br></code></pre></div><div class='codearea'><pre><code># バリオグラムを図示(乱数なので、場合によって変わります）<br>ndvi_vario &lt- variogram(NDVI~x+y, data=ndvi_miss, cressie=T)<br>plot(ndvi_vario,pch=1,cex=1.2) # まず、バリオグラムの様子を確認（下図左）<br># variogram()の引数として、cloud=Tを加えると、バリオグラム雲を表示できる。<br></code></pre></div><br><div class='fig'><a href='./a2/2.png'><img src='./a2/2.png' class='fig'></a><p class='legend'>バリオグラムの様子を確認。</p></div><br><div class='codearea'><pre><code># バリオグラムの近似曲線を決定（見た目から、それっぽい初期値を決める）<br>my.psill &lt- 0.008 # シル<br>my.range &lt- 0.012 # レンジ<br>my.nugget &lt- 0.001 # ナゲット<br>dat.fit &lt- fit.variogram(ndvi_vario, vgm(model="Sph", psill=my.psill, range=my.range, nugget=my.nugget), fit.method=1)<br># モデル(model引数)はいろいろあるから、適宜選ぶ。<br>#（Sphは球形モデル、Expは指数モデル、Linは線形モデル、Gauはガウスモデル、Nugはナゲット効果モデル、MatはMaternモデル）<br># fit.method引数は、ググってください。<br><br>dat.fit # 結果の表示（いい感じに、シル、レンジ、ナゲットを推定してくれる）<br></code></pre></div><div class='codearea'><pre><code>dat.fitによる結果の表示（いい感じに、シル、レンジ、ナゲットを推定してくれる）<br><br>   model       psill      range <br>1   Nug 0.000000000 0.00000000 <br>2   Sph 0.009432095 0.01966746 <br></code></pre></div><div class='codearea'><pre><code>f.psill &lt- dat.fit$psill[2] # 推定したシルの取り出し<br>f.range &lt- dat.fit$range[2] # 推定したレンジの取り出し<br>f.nugget &lt- dat.fit$psill[1] # 推定したナゲットの取り出し<br><br>plot(ndvi_vario,dat.fit, pch=20, cex=1.5, col=1) # 前頁図（右）<br>m &lt- vgm(f.psill, "Sph", f.range, f.nugget) # モデルとして記録<br></code></pre></div><div class='fig'><a href='./a2/3.png'><img src='./a2/3.png' class='fig'></a><p class='legend'>バリオグラムの近似曲線を決定。</p></div><div class='codearea'><pre><code># 空間補間の状況を図示するためにグリッド(描画時の升目)を用意<br># ここでは、もともとのデータのグリッドを用いる。<br>ndvih_coord &lt- coordinates(ndvih) # 各ポリゴンの代表点を抽出<br># データ型をSpatialPoints型に変換<br>dat.grid &lt- SpatialPoints(ndvih_coord, proj4string=CRS(as.character(NA)))<br># データ型をSpatialPixel型に変換（要らないかも？）<br>dat.grid &lt- spsample(dat.grid,type="regular")<br>gridded(dat.grid) = TRUE # よくわからないが必要<br><br># krige()関数を用いる。元のデータ(ndvi_miss)、バリオグラムの近似モデル(m)、グリッド(dat.grid)を合わせて空間補間を行う。<br>spplot(ndvi_miss["NDVI"]) #inputデータの分布図<br># 通常クリギング<br>krige &lt- krige(NDVI~1, ndvi_miss, dat.grid, model = m)<br>plot(krige["var1.pred"], axes=TRUE) <br>contour(krige["var1.pred"], col="white", add=T) # 等値線を引く。<br></code></pre></div><div class='fig'><a href='./a2/4.png'><img src='./a2/4.png' class='fig'></a><p class='legend'>クリギングの結果（データ量はオリジナルの10分の1）。</p></div><div class='codearea'><pre><code># クリギングデータの出力 <br># ラスタデータとして出力する<br>writeRaster(raster(krige["var1.pred"]), "krigeNDVI10.tiff", format="Gtiff") # GeoTiff（拡張子.tif）を指定して出力。<br># format=“ascii”（ESRI Ascii（拡張子.asc））等、ほかの形式も指定できる。<br># Ascii の場合、縦横の解像度はほぼ同一にしておく（メッシュを作る際に注意）。<br></code></pre></div><div class='fig'><a href='./a2/5.png'><img src='./a2/5.png' class='fig'></a><p class='legend'>ESRI Ascii ラスターデータとして出力したクリギングの結果をQGISで表示した。等値線は、QGISの機能（ラスタ→抽出→等高線）を用いて作成した。他のデータ形式（GeoTIFF等）も出力できる。また、データの変換は、QGISを通してできる。</p></div><div class='codearea'><pre><code>#点データとしても出力できる。<br>writePointsShape(krige,"krige_NDVI_10.shp") <br></code></pre></div><div class='fig'><a href='./a2/6.png'><img src='./a2/6.png' class='fig'></a><p class='legend'>出力したクリギングデータ（krig_NDVI_10）を、QGISで表示したもの。背景に、オリジナルのメッシュデータ（NDVImesh16_0707）を用いた。</p></div><p>上記の内容を一般化した内容が以下のコードです。<br>唐突ですが、IDW (逆距離過重補完)の解説も入れています。<br>sample.shpのvalueという値を補間することにしましょう。<br>（選択肢2として、CSVファイルなどからコピーしたデータを取り込む方法も示しています。）</p><div class='codearea'><pre><code>### IDW・クリギング手順まとめ ####################################<br>library(spdep)<br>library(maptools)<br>library(gstat)<br>library(sp)<br>library(raster)<br><br>### データの準備 ###<br>## 選択肢１：シェープファイルを利用する（例:sample.shp）<br># シェープファイル（ポリゴンまたはポイント）を読み込む。<br>shape &lt- readShapePoly(<font color='blue'>"sample.shp"</font>) # ポリゴンの場合 <br>shape &lt- readShapePoints(<font color='blue'>"sample.shp"</font>) # ポイントの場合<br>plot(shape, axes=T) # ポリゴンの表示<br>coord &lt- coordinates(shape) # 各ポリゴン・ポイントの代表点を抽出<br>sdata &lt- cbind(coord[,1], coord[,2], shape<font color='blue'>$value</font>) # 行列構成<br><br>## 選択肢２：データフレーム(Excelなど)から、座標と測定値データを取得する。<br>df &lt- read.table("clipboard", header=TRUE) # サンプリング点データ<br>EB &lt- cbind(df[,2], df[,1]) # 経度、緯度の順に取り出し、EBに格納<br>sdf &lt- SpatialPointsDataFrame(EB, df) <br>coord &lt- coordinates(sdf) # サンプリングポイントの座標<br>sdata &lt- cbind(coord[,1], coord[,2], df[,3]) # 行列構成<br><br>### 行列データの整理と変換 ###<br>colnames(sdata) &lt- c("x","y","value") # 列名を付ける<br>sdata &lt- as.data.frame(sdata) # データフレームに変換<br># データ形式をSpatialPointsDataFrameに変換する<br>coords &lt- cbind(sdata$x,sdata$y) # x,y座標をペアにする<br>sdata &lt- SpatialPointsDataFrame(coords, sdata)<br><br>### 予測グリッドの作成 ###<br>p &lt- (max(coord[,1])-min(coord[,1]))/(max(coord[,2])-min(coord[,2]))<br>p # 縦横比を出力。だいたい、縦横比が同じになるように調整する。<br># 上の縦横比に合わせて、引数lengthの大きさを変更する。<br>x.grid &lt- seq(min(coord[,1]), max(coord[,1]), length=50)<br>y.grid &lt- seq(min(coord[,2]), max(coord[,2]), length=50)<br>loc &lt- expand.grid(x.grid, y.grid)<br>colnames(loc) &lt- c(“x.grid”, “y.grid”)<br># メッシュのデータ型をSpatialPoints型に変換<br>loc &lt- SpatialPoints(loc, proj4string=CRS(as.character(NA)))<br># メッシュのデータ型をSpatialPixel型に変換<br>loc &lt- as(loc, “SpatialPixelDataFrame”)<br>gridded(loc) = TRUE<br><br><br>### バリオグラムの近似曲線を決定###<br>vario &lt- variogram(value~x+y, data=sdata, cressie=T)<br>plot(vario,pch=1,cex=1.2) # バリオグラムの様子を確認<br><br>my.psill &lt- 200  # シル（見た目から、それっぽい初期値を決める）<br>my.range &lt- 0.03  # レンジ（見た目から、それっぽい初期値を決める）<br>my.nugget &lt- 0  # ナゲット（見た目から、それっぽい初期値を決める）<br><br>dat.fit &lt- fit.variogram(vario, vgm(model=<font color='blue'>"Sph"</font>, psill=my.psill, range=my.range, nugget=my.nugget), fit.method=1)<br># モデル(model引数)はいろいろあるから、適宜選ぶ <br>   # Sphは球形モデル、Expは指数モデル、<br>   # Gauはガウスモデル、Linは線形モデル、<br>   # Nugはナゲット効果モデル、MatはMaternモデル<br># fit.method引数は、ググってください。（自分はよくわかってない。）<br>dat.fit # 結果の表示（シル、レンジ、ナゲットを推定してくれる）<br>plot(vario, dat.fit, pch=20, cex=1.5, col=1) # バリオグラム表示<br>f.psill &lt- dat.fit$psill[2] # 推定したシルの取り出し<br>f.range &lt- dat.fit$range[2] # 推定したレンジの取り出し<br>f.nugget &lt- dat.fit$psill[1] # 推定したナゲットの取り出し<br>m &lt- vgm(f.psill, "Sph", f.range, f.nugget) # モデルとして記録<br><br>### クリギング補間###<br># 通常クリギング（グリッドが細かい、データ数が多いと遅くなるので注意）<br>gs &lt- gstat(id="value", formula=value~1, data=sdata, model=m)<br>krige1 &lt- predict(gs, loc)<br>plot(krige1[1], axes=T)<br>contour(krige1[1], col="white", add=T)<br><br>### クリギング結果の出力###<br>writeRaster(raster(krige1[1]), "krig_pred.tiff", format="GTiff") # GeoTiff（拡張子.tif）で予測値を出力。<br># 引数にoverwrite=TRUEを加えると、上書きできる。<br># GeoTiffでうまく出力できないときは、format="ascii"として、<br># ESRI Ascii（拡張子.asc）で出力。その場合、縦横の解像度はほぼ同じに。<br><br><br>### IDW (逆距離過重補完)###<br>data_idw &lt- as.data.frame(sdata) # ただのデータフレームにする<br>IDW &lt- idw(value~1, locations=~x+y, data=data_idw, loc, idp=2)<br>plot(IDW, axes=T)<br>contour(IDW["var1.pred"], col="white", add=T)<br><br>### おわり ######################################################<br></code></pre></div><p>このコードは昔書いた遺物なんだけど、利用価値を高めるために公開してみた。<br>けど、ここでHTML書いて公開するより、GitHub本家にコード上げれば済むと言う話でもある（もうすでに上げてある）。このHTMLファイルを作るのにそれなりの時間をかけたけど、見る人はいないだろうし、忘備録的に残すのであれば、GitHubにコードを載せて、そのコードにしっかりコメントを書いておくことで十分な気がする。<br>結局、どのツールをどのように有効活用すればいいのかよくわかっていないんだよなぁ。</p>    </div> <div class='attention'><p>
注意事項<br>本Webサイトで提供する情報の利用は自己責任でお願いいたします。また、画像や文章の著作権は放棄しておりません。
</p></div><div class='history'><p> <p> 2018年12月15日公開 </p></p></div></body></html>
